/*
 * Copyright (C) 2020 PekinSOFT™ Systems
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * *****************************************************************************
 * 
 * Project :   Load Master™
 * Class   :   AbstractJournal
 * Author  :   Sean Carrick
 * Created :   Oct 25, 2020
 * Modified:   Oct 25, 2020
 * 
 * Purpose:
 *     Provides the framework for all Journal controller classes in Load Master™.
 * 
 * WHEN          BY                  REASON
 * ------------  ------------------  -------------------------------------------
 * Oct 25, 2020  Sean Carrick        Initial creation.
 * 
 * *****************************************************************************
 */

package com.pekinsoft.loadmaster.api;

import com.pekinsoft.loadmaster.Starter;
import com.pekinsoft.loadmaster.err.DataStoreException;
import com.pekinsoft.loadmaster.view.LoadMaster;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.time.Instant;
import java.util.ArrayList;

/**
 *
 * @author Sean Carrick &lt;sean at pekinsoft dot com&gt;
 * 
 * @param <T>
 * 
 * @version 0.1.0
 * @since 0.1.0
 */
public abstract class AbstractJournal<T> {
    
    //<editor-fold defaultstate="collapsed" desc="Protected Fields">
    protected File table;
    
    protected ArrayList<T> records;
    protected LogRecord entry;
    protected boolean fileJustCreated;
    protected T record;
    
    protected int row;
    //</editor-fold>
    
    //<editor-fold defaultstate="collapsed" desc="Constructor(s)">
    /**
     * Creates a new instance of the `AbstractJournal` class for accessing the
     * journal file for whichever account is extending this class.
     * 
     * @throws DataStoreException in the event that the database access fails.
     */
    public AbstractJournal(T obj, String pathToFile) throws DataStoreException {
        entry = new LogRecord(Level.ALL, "Logging started in the "
                + getClass().getCanonicalName());
        
        table = new File(pathToFile);
        
        records = new ArrayList<>();
        record = obj;
        
        row = 0;
        fileJustCreated = createFileIfNecessary();
        
        if ( !fileJustCreated ) {
            connect();
        } else {
            entry.setMessage("Fuel Card Journal was just created.");
            entry.setSourceClassName(getClass().getCanonicalName());
            entry.setSourceMethodName(getClass().getName() + " (Constructor)");
            entry.setParameters(null);
            entry.setThrown(null);
            entry.setInstant(Instant.now());
            Starter.logger.info(entry);
        }
    }
    //</editor-fold>
    
    //<editor-fold defaultstate="collapsed" desc="Abstract Method Declarations">
    /**
     * Loads the data from the table format into the entry model object. Since
     * the entry model object is also responsible for creating the record from
     * the entry model data in a table formatted record, the entry model can
     * easily place the data fields into the appropriate fields. The order of 
     * the array of data is the same as the order that was written to the table
     * data file, generated by the method `createTableRecord`.
     * 
     * @param line from the data file, split into a `java.lang.String[]` array
     *             on the file's delimiter.
     */
    protected abstract void load(String[] line);
    
    /**
     * Creates a record from the entry model data, formatted for the table data
     * file. Each entry model is able to determine how the data fields are 
     * separated and the order the fields are written out to the data file. This
     * allows them to best determine what works for the table whose records they
     * represent.
     *  
     * @param model the `T` object that contains the data being written to file.
     * @return a `java.lang.String` containing all of the data from the model,
     *         formatted into fields split by a delimiter, ready to be written
     *         out to the data file.
     */
    protected abstract String createTableRecord(T model);
    
    /**
     * This method performs the task of posting all unposted transactions from
     * this journal to the General Ledger. 
     * 
     * This method should called in accordance with the application settings 
     * Posting Method. If the selected Posting Method is Batch Posting, then the
     * user will need to manually post the Journals to the General Ledger.
     * Alternatively, if there are unprocessed Journal entries when the user
     * exits the application, the application can prompt the user to allow it to
     * process the batched transactions. If the user chooses to not allow the
     * application to process those Journal entries then, the application should
     * store that fact to the settings file and check the setting on the next
     * launch. If, at the next launch, there are unprocessed Journal entries, 
     * the application should somehow show a reminder to the user that there are
     * unprocessed batched transactions that still need to be posted to the 
     * General Ledger.
     * 
     * If the user has chosen to batch process Journal entries to the General
     * Ledger, then the user needs to be reminded once in a while to click on
     * the "Post Transactions" task in the "Accounting Tasks" task pane. The
     * broken down information regarding revenue, expense, and profit (per mile)
     * is only calculated from the General Ledger and not from any of the 
     * Journals. Therefore, if the user wants the most accurate quick info 
     * regarding the financial health of their company, they need to post their
     * batched transactions as soon as they are able.
     *  
     * @return  success: `true` if transactions posted, `false` otherwise.
     * @throws DataStoreException in the event there is an error accessing the
     *                            database.
     */
    public abstract boolean postTransactions() throws DataStoreException;
    //</editor-fold>
    
    //<editor-fold defaultstate="collapsed" desc="Private Methods">
    /**
     * Checks for the existence of the database file and creates it if it does
     * not yet exist.
     * 
     * @return success: `true` if successful, `false` on failure.
     */
    private boolean createFileIfNecessary() {
        boolean success = true;
        if ( !table.exists() ) {
            try {
                table.createNewFile();
            } catch (IOException ex) {
                entry.setMessage(ex.getMessage() + "\n\n" + "-".repeat(80)
                        + "\nThrowing DataStoreException...");
                entry.setParameters(null);
                entry.setSourceMethodName("createFileIfNecessary");
                entry.setThrown(ex);
                Starter.logger.error(entry);
                
                success = false;
            }
        }
        
        return success;
    }
    
    /**
     * Connects the AbstractJournal controller object to the database file for
     * its data.
     * 
     * @throws DataStoreException in the event that the database access fails.
     */
    private void connect() throws DataStoreException {
        entry.setMessage("Enter...");
        entry.setSourceMethodName("connect");
        entry.setParameters(new Object[]{});
        Starter.logger.enter(entry);
        
        BufferedReader in;
        
        entry.setMessage("Setting up LoadMaster.fileProgress...");
        entry.setParameters(null);
        Starter.logger.config(entry);
        
        if ( LoadMaster.fileProgress != null ) {
            LoadMaster.fileProgress.setMaximum(
                    Starter.props.getPropertyAsInt("journal.fuel.card.records", "0") 
                    + (Starter.props.getPropertyAsInt("journal.fuel.card.records", "0")));
            LoadMaster.fileProgress.setValue(0);
            LoadMaster.fileProgress.setVisible(true);
        }
        
        try {
            in = new BufferedReader(new FileReader(table));
            
            String line = in.readLine();
            
            while ( line != null ) {
                String[] splitLine = line.split("~");
                
                load(splitLine);
                
                line = in.readLine();

                if ( LoadMaster.fileProgress != null ) {
                    LoadMaster.fileProgress.setValue(
                            LoadMaster.fileProgress.getValue() + 1);
                }
            }
            
            in.close();
            
        } catch ( IOException ex ) {
            entry.setMessage(ex.getMessage() + "\n\n" + "-".repeat(80)
                    + "Throwing DataStoreException to calling method...");
            entry.setThrown(ex);
            entry.setSourceMethodName("connect");
            entry.setParameters(null);
            Starter.logger.error(entry);
            
            throw new DataStoreException(ex.getMessage(), ex);
        } finally {
            if ( LoadMaster.fileProgress != null ) {
                LoadMaster.fileProgress.setValue(0);
                LoadMaster.fileProgress.setVisible(false);
            }
            Starter.props.setPropertyAsInt("journal.fuel.card.records", records.size());
            Starter.props.flush();
        }
    }
    //</editor-fold>
    
    //<editor-fold defaultstate="collapsed" desc="Protected Instance Methods">
    
    /**
     * Saves the transaction data from this model out to the database.
     * 
     * @throws DataStoreException in the event a error occurs accessing the 
     *                            database
     */
    protected void save() throws DataStoreException {
        BufferedWriter out;
        
        LoadMaster.fileProgress.setMaximum(
                Starter.props.getPropertyAsInt("journal.fuel.card.records", "0"));
        LoadMaster.fileProgress.setValue(
                Starter.props.getPropertyAsInt("journal.fuel.card.records", "0"));
        
        if ( table.exists() ) {
            table.delete();
            try {
                table.createNewFile();
            } catch ( IOException ex ) {
                entry.setMessage("Something went wrong deleting and recreating "
                        + "the data table.");
                entry.setThrown(ex);
                entry.setSourceMethodName("save");
                entry.setParameters(null);
                Starter.logger.error(entry);
                
                throw new DataStoreException(ex.getMessage(), ex);
            }
        }
        
        try {
            out = new BufferedWriter(new FileWriter(table));
            
            for ( int x = 0; x < records.size(); x++ ) {
                out.write(createTableRecord(records.get(x)) + "\n");
                
                LoadMaster.fileProgress.setValue(
                        LoadMaster.fileProgress.getValue() - 1);
            }
            
            out.close();
        } catch ( IOException ex ) {
            entry.setMessage(ex.getMessage() + "\n\n" + "-".repeat(80)
                    + "Throwing DataStoreException to calling method...");
            entry.setThrown(ex);
            entry.setSourceMethodName("storeData");
            entry.setParameters(null);
            Starter.logger.error(entry);
            
            throw new DataStoreException(ex.getMessage(), ex);
        }
    }
    //</editor-fold>
    
    //<editor-fold defaultstate="collapsed" desc="Public Concrete Methods">
    /**
     * Closes the connection to the data store file. Prior to closing the 
     * connection, the records contained within this controller are saved back
     * to file. After the call to this method, this object is no longer 
     * available for use. Prior to attempting to use it again, you will need to
     * reinitialize the object.
     */
    public void close() {
        flush();
        
        records = null;
        entry = null;
        record = null;
        table = null;
    }
    
    /**
     * Flushes the data contained within this journal to its data file. The 
     * connection to the data file remains open after calling this method.
     */
    public void flush() {
        entry.setSourceClassName(getClass().getCanonicalName());
        entry.setSourceMethodName("flush");
        entry.setLevel(Level.FINE);
        entry.setParameters(null);
        entry.setThrown(null);
        entry.setMessage("Attempting to flush the data to the data file.");
        entry.setInstant(Instant.now());
        Starter.logger.enter(entry);
        
        try {
            save();
        } catch ( DataStoreException ex ) {
            entry.setSourceMethodName("flush");
            entry.setLevel(Level.SEVERE);
            entry.setThrown(ex);
            entry.setMessage(ex.getLocalizedMessage());
            entry.setInstant(Instant.now());
            Starter.logger.error(entry);
        } finally {
            entry.setLevel(Level.FINE);
            entry.setParameters(null);
            entry.setThrown(null);
            entry.setMessage("Attempting to flush the data to the data file.");
            entry.setInstant(Instant.now());
            Starter.logger.exit(entry, null);
        }
    }
    
    /**
     * Provides a means of adding a new `T` object to the database.
     * 
     * @param model the new model to add.
     */
    public void addNew(T model) {
        records.add(model);
        row = getRecordCount() - 1;
    }
    
    /**
     * Moves the record pointer to the first transaction in this journal.
     * 
     * @return T the requested transaction record, or `null` if an error occurs.
     * @throws DataStoreException in the event an error occurs while accessing
     *                       the journal
     */
    public T first() throws DataStoreException {
        if ( row > 0 ) {
            row = 0;
            
            try {
                record = records.get(row);
            } catch ( IndexOutOfBoundsException ex ){
                record = null;
                throw new DataStoreException("Error occurred navigating records."
                        + "\n\n" + ex.getMessage(), ex);
            }
        }
        
        return record;
    }
    
    /**
     * Moves the record pointer to the previous transaction in this journal.
     * 
     * @return T the requested transaction record, if not at the first
     *                       transaction in the journal, or `null` if an error 
     *                       occurs.
     * @throws DataStoreException in the event an error occurs while accessing
     *                       the journal
     */
    public T previous() throws DataStoreException {
        if ( row > 0 ) {
            row--;
            
            try {
                record = records.get(row);
            } catch (IndexOutOfBoundsException ex) {
                record = null;
                throw new DataStoreException("Error occurred navigating records."
                        + "\n\n" + ex.getMessage(), ex);
            }
        }
        
        return record;
    }
    
    /**
     * Moves the record pointer to the next transaction in this journal.
     * 
     * @return T the requested transaction record, if not at the first
     *                       transaction in the journal, or `null` if an error 
     *                       occurs.
     * @throws DataStoreException in the event an error occurs while accessing
     *                       the journal
     */
    public T next() throws DataStoreException {
        if ( row < records.size() ) {
            row++;
            
            try {
                record = records.get(row);
            } catch (IndexOutOfBoundsException ex) {
                record = null;
                throw new DataStoreException("Error occurred navigating records."
                        + "\n\n" + ex.getMessage(), ex);
            }
        }
        
        return record;
    }
    
    /**
     * Moves the record pointer to the last transaction in this journal.
     * 
     * @return T the requested transaction record, if not at the last
     *                       transaction in the journal, or `null` if an error 
     *                       occurs.
     * @throws DataStoreException in the event an error occurs while accessing
     *                       the journal
     */
    public T last() throws DataStoreException {
        if ( row < records.size() ) {
            row = records.size() - 1;
            
            try {
                record = records.get(row);
            } catch (IndexOutOfBoundsException ex) {
                record = null;
                throw new DataStoreException("Error occurred navigating records."
                        + "\n\n" + ex.getMessage(), ex);
            }
        }
        
        return record;
    }
    
    /**
     * Determines whether or not there are more transactions in this journal.
     * 
     * @return `true` if more transactions, `false` if not.
     */
    public boolean hasNext() {
        return row < records.size();
    }
    
    /**
     * Retrieves the current entry as an `T` object.
     * 
     * @return The current entry.
     */
    public T get() {
        return records.get(row);
    }
    
    /**
     * Retrieves the entry at the specified index. If the specified index is
     * invalid, returns `null`.
     * 
     * @param idx   The specified index from which to retrieve the entry.
     * @return      The entry at the specified index. If the specified index is 
     *              invalid (i.e., less than zero or greater than
     *              `getRecordCount()`), null is returned.
     */
    public T get(int idx) {
        T obj;
        
        try {
            obj = records.get(idx);
        } catch ( IndexOutOfBoundsException ex ) {
            obj = null;
        }
        
        return obj;
    }
    
    /**
     * Retrieves the current record number of the record in this journal.
     * 
     * @return int The current record number
     */
    public int getCurrentRecordNumber() {
        return row + 1;
    }
    
    /**
     * Replaces the entry at the current position in the table with the 
     * specified entry.
     * 
     * @param model `T` with the changes made.
     */
    public void update(T model) {
        record = model;
        
        records.set(row, model);
    }
    
    /**
     * Retrieves the total number of records (or rows) in this table.
     * 
     * @return int The number of records
     */
    public int getRecordCount() {
        return records.size();
    }
    //</editor-fold>

}
